/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\PathExpression.jj */
/*@egen*//**
 * Copyright 2008 University of Washington Structural Informatics Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options
{
	           
	STATIC=false; // could set this to true and use ReInit()
}

PARSER_BEGIN(PathExpression)
package edu.washington.sig.gleen.javacc.grammar;
public class PathExpression/*@bgen(jjtree)*/implements PathExpressionTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPathExpressionState jjtree = new JJTPathExpressionState();

/*@egen*/

  public static void main(String args[]) {
    ByteArrayInputStream str = new ByteArrayInputStream(args[0].getBytes());
    PathExpression t = new PathExpression(str);
    try {
      SimpleNode n = t.Start();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

}
PARSER_END(PathExpression)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : 
{
  < LGROUP: "(" >
| < RGROUP: ")" >
| < CONCAT: "/" >
| < ALT: "|" >
| < STAR: "*" >
| < PLUS: "+" >
| < OPT: "?" >
| < PROPERTY: "["(<PROPERTY_CHAR>)+"]" >
| < #PROPERTY_CHAR: ~["[","]"] >
}

SimpleNode Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
  	Expr()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Expr()       : {}
{
  	BinaryOpExpr()
}

void SubExpr()       : {}
{
  	<LGROUP> Expr() <RGROUP> | SimpTerm()
}

void BinaryOpExpr()                        : {/*@bgen(jjtree) #BinaryOpExpr( t != null) */
                                               ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
                                               boolean jjtc000 = true;
                                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) #BinaryOpExpr( t != null) */
        try {
/*@egen*/
	UnaryOpExpr() [((t=<CONCAT>) BinaryOpExpr())+ | ((t=<ALT>) BinaryOpExpr())+]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000,  t != null);
          jjtc000 = false;
        }
/*@egen*/
	{
		if(t!=null)
		{
			jjtn000.setOperatorType(t.kind);
			jjtn000.setOperator(t.image);
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  t != null);
          }
        }
/*@egen*/
}

void UnaryOpExpr()                       : {/*@bgen(jjtree) #UnaryOpExpr( t != null) */
                                             ASTUnaryOpExpr jjtn000 = new ASTUnaryOpExpr(JJTUNARYOPEXPR);
                                             boolean jjtc000 = true;
                                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) #UnaryOpExpr( t != null) */
        try {
/*@egen*/
	SubExpr() [t=<STAR>|t=<PLUS>|t=<OPT>]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000,  t != null);
          jjtc000 = false;
        }
/*@egen*/
	{
		if(t!=null)
		{
			jjtn000.setOperatorType(t.kind);
			jjtn000.setOperator(t.image);
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  t != null);
          }
        }
/*@egen*/
}

void SimpTerm() : {/*@bgen(jjtree) SimpTerm */
                    ASTSimpTerm jjtn000 = new ASTSimpTerm(JJTSIMPTERM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SimpTerm */
        try {
/*@egen*/
	t = <PROPERTY>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setOperatorType(t.kind);
    	jjtn000.setOperator(t.image);
  	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
